# Control Structures

[control] Traditional procedural control structures exist in Nit. They
also often exist in two versions: a one-liner and a block version.

## Control Flow

[control flow] Control structures dictate the control flow of the
program. Nit heavily refers to the control flow in its specification:

-   No unreachable statement;

-   No usage of undefined variables;

-   No function without a `return` with a value;

-   Adaptive typing.

Some structures alter the control flow but are not described in this
section: `and`, `or`, `not`, `or else` and `return`.

Note that the control flow is determined only from the position, the
order and the nesting of the control structures. The real value of the
expressions used has no effect on the control flow analyses.

2

    if true then
        return
    else
        return
    end
    print 1
    # Compile error: 
    # unreachable statement

    if true then
        return
    end
    print 1
    # OK, but never executed

## if

[if]

2

    if exp then stm
    if exp then stm else stm
    if exp then
        stms
    end

    if exp then
        stms
    else if exp then
        stms
    else
        stms
    end

Note that the following example is invalid since the first line is
syntactically complete thus the newline terminate the whole `if`
structure; then an error is signaled since a statement cannot begin with
`else`.

    if exp then stm # OK: complete 'if' structure
    else stm # Syntax error: unexpected 'else'

## while

[while]

    while exp do stm
    while exp do
        stms
    end

## for

[for] `for` declares an automatic variable used to iterates on
`Collection` (`Array` and `Range` are both `Collection`).

    for x in [1..5] do print x # outputs 1 2 3 4 5
    for x in [1, 4, 6] do
        print x # outputs 1 4 6
    end

In fact, `for` is syntactic sugar for a closure.

## loop

[loop] Infinite loops are mainly used with breaks. They are useful to
implement *until* loops or to simulate the *exit when* control of Ada.

    loop
        stms
        if exp then break
        stms
    end

Note that `loop` is different from `while true` because the control flow
does not consider the values of expression.

## do

[do] Single `do` are used to create scope for variables or to be
attached with labeled breaks.

    do
        var x = 5
        print x
    end
    # x is not defined here

## break, continue and label

[break][continue][label] Unlabeled `break` exits the current `for`,
`while`, `loop`, or closure. Unlabeled `continue` skips the current
`for`, `while`, `loop`, or closure.

`label` can be used with `break` or `continue` to act on a specific
control structure (not necessary the current one). The corresponding
`label` must be defined after the `end` keyword of the designated
control structure.

    for i in [0..width[ do
        for j in [0..height[ do
            if foo(i, j) then break label outer_loop
            # The 'break' breaks the 'for i' loop
        end
    end label outer_loop

`label` can also be used with `break` and single `do` structures.

    do
        stmts
        if expr then break label block
        stmts
    end label block

In closures, `break` and `continue` can return values.

## abort

[abort] `abort` stops the program with a fatal error and prints a stack
trace. Since there is currently no exception nor run-time-errors, abort
is somewhat used to simulate them.

## assert

[assert] `assert` verifies that a given Boolean expression is true, or
else it aborts. An optional label can be precised, it will be displayed
on the error message. An optional `else` can also be added and will be
executed before the abort.

    assert bla: whatever else
        # "bla" is the label
        # "whatever" is the expression to verify
        print "Fatal error in module blablabla."
        print "Please contact the customer service."
    end

# Local Variables and Static Typing

[var][static type] `var` declares local variables. In fact there is no
global variable in Nit, so in this document *variable* always refers to
a local variable. A variable is visible up to the end of the current
control structure. Two variables with the same name cannot coexist: no
nesting nor masking.

Variables are bound to values. A variable cannot be used unless it has a
value in all control flow paths (Ã  la Java).

    var x
    var y
    if whatever then
        x = 5
        y = 6
    else
        x = 7
    end
    print x # OK
    print y # Compile error: y is possibly not initialized

## Adaptive Typing

[adaptive typing] Nit features adaptive typing, which means that the
static type of a variable can change according to: the assignments of
variables, the control flow, and some special operators (`and`, `or`,
`or else`, `==`, `!=`, and `isa`).

2

    var x # a variable
    x = 5
    # static type is Int
    print x + 1 # outputs 6
    x = [6, 7]
    # static type is Array[Int]
    print x[0] # outputs "6"

    var x
    if whatever then
        x = 5
    else
        x = 6
    end
    # Static type is Int

## Variable Upper Bound

[upper bound] An optional type information can be added to a variable
declaration. This type is used as an upper bound of the type of the
variable. When a initial value is given in a variable declaration
without a specific type information, the static type of the initial
value is used as an upper bound. If no type and no initial value are
given, the upper bound is set to `nullable Object`.

    var x: Int # Upper bound is Int
    x = "Hello" # Compile error: expected Int
    var y: Object # Upper bound is Object
    y = 5 # OK since Int specializes Object
    var z = 5 # Upper bound is Int
    z = "Hello" # Compile error: expected Int
    var t: Object = 5 # Upper bound is Object
    t = "Hello" # OK

The adaptive typing flow is straightforward, therefore loops (`for`,
`while`, `loop`) and closures have a special requirement: on entry, the
upper bound is set to the current static type; on exit, the upper bound
is reset to its previous value.

    var x: Object = ...
    # static type is Object, upper bound is Object
    x = 5
    # static type is Int, bound remains Object
    while x > 0 do
        # static type remains Int, bound sets to Int
        x -= 1 # OK
        x = "Hello" # Compile error: expected Int
    end
    # static type is Int, bound reset to Object
    x = "Hello" # OK

## Type Checks

[isa] `isa` tests if an object is an instance of a given type. If the
expression used in an `isa` is a variable, then its static type is
automatically adapted, therefore avoiding the need of a specific cast.

    var x: Object = whatever
    if x isa Int then
        # static type of x is Int
        print x * 10 # OK
    end

Remember that adaptive typing follows the control flow, including the
Boolean operators.

    var a: Array[Object] = ...
    for i in a do
        # the static type of i is Object 
        if not i isa Int then continue
        # now the static type of i is Int
        print i * 10 # OK
    end

An interesting example:

    var max = 0
    for i in whatever do
        if i isa Int and i > max then max = i
        # the > is valid since, in the right part
        # of the "and", the static type of i is Int
    end

Note that type adaptation occurs only in an `isa` if the target type is
more specific that the current type.

    var a: Collection[Int] = ...
    if a isa Comparable then
        # the static type is still Collection[Int]
        # even if the dynamic type of a is a subclass
        # of both Collection[Int] and Comparable
        ...
    end

## Nullable Types

[null][nullable][or else][not null] `null` is a literal value that is
only accepted by some specific static types. However, thanks to adaptive
typing, the static type management can be mainly automatic.

`nullable` annotates types that can accept `null` or an expression of a
compatible nullable static type.

    var x: nullable Int
    var y: Int
    x = 1 # OK
    y = 1 # OK
    x = null # OK
    y = null # Compile error
    x = y # OK
    y = x # Compile error

Adaptive typing works well with nullable types.

    var x
    if whatever then
        x = 5
    else
        x = null
    end
    # The static type of x is nullable Int

Moreover, like the `isa` keyword, the `==` and `!=` operators can adapt
the static type of a variable when compared to `null`.

    var x: nullable Int = whatever
    if x != null then
        # The static type of x is Int (without nullable)
        print x + 6
    end
    # The static type of x is nullable Int

And another example:

    var x: nullable Int = whatever
    loop
        if x == null then continue
        # The static type of x is Int
    end

`or else` can be used to compose a nullable expression with any other
expression. The value of `x or else y` is `x` if `x` is not `null` and
is `y` if `x` is null. The static type of `x or else y` is the
combination of the type of `y` and the not null version of the type of
`x`.

    var i: nullable Int = ...
    var j = i or else 0
    # the static type of j is Int (without nullable)

Note that nullable types require a special management for attributes and
constructors.

## Explicit Cast

[as] `as` casts an expression to a type. The expression is either casted
successfully or there is an `abort`.

    var x: Object = 5 # static type of x is Object
    print x.as(Int) * 10 # outputs 50
    print x.as(String) # aborts: cast failed

Note that `as` does not change the object nor does perform conversion.

    var x: Object = 5 # static type of x is Object
    print x.as(Int) + 10 # outputs "15"
    print x.to_s + "10" # outputs "510"

Because of type adaptation, `as` is rarely used on variables. `isa`
(sometime coupled with `assert`) is preferred.

    var x: Object = 5 # static type of x is Object
    assert x isa Int
    # static type of x is now Int
    print x * 10 # outputs 50

`as(not null)` can be used to cast an expression typed by a nullable
type to its non nullable version. This form keeps the programmer from
writing explicit static types.

    var x: nullable Int = 5 # static type of x is nullable Int
    print x.as(not null) * 10 # cast, outputs 50
    print x.as(Int) * 10 # same cast, outputs 50
    assert x != null # same cast, but type of x is now Int
    print x * 10 # outputs 50

## Static Type Combination Rule

[combination] Adaptive typing, literal arrays, `or else`, and valued
`break` in closure need to determine a static type by combining other
static types. This is done by using the following rule:

-   The final type is `nullable` if at least one of the types is
    `nullable`.

-   The final type is the static type that is more general than all the
    other types.

-   If there is no such a type, and the thing typed is a variable, then
    the final type is the upper bound type of the variable; else there
    is a compilation error.

<!-- -->

    var d: Discrete = ...
    # Note: Int < Discrete < Object
    var x
    if whatever then x = 1 else x = d
    # static type is Discrete
    if whatever then x = 1 else x = "1"
    # static type is nullable Object (upper bound)
    var a1 = [1, d] # a1 is a Array[Discrete]
    var a2 = [1, "1"] # Compile error:
            # incompatible types Int and String 


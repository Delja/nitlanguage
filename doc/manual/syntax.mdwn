# Basic Syntax fo Nit

The syntax of Nit belongs to the Pascal tradition and is
inspired by various script languages (especially Ruby). Its objective is
readability.

Indentation is not meaningful in Nit; blocks usually starts by a
specific keyword and finish with `end`. Newlines are only meaningful at
the end of declarations, at the end of statements, and after some
specific keywords. The philosophy is that the newline is ignored if
something (a statement, a declaration, or whatever) obviously needs more
input; while the newline terminates lines that seems completed. See the
complete Nit grammar for more details.

    print 1 + 1 # a first complete statement that outputs "2"
    print 2 + # the second statement is not yet finished
    2 # the end of the second statement, outputs "4"

Nit tries to achieve some uniformity in its usage of the common
punctuation: equal (`=`) is for assignment, double equal (`==`) is for
equality test, column (`:`) is for type declaration, dot (`.`) is for
polymorphism, comma (`,`) separates elements, and quad (`::`) is for
explicit designation.

## Identifiers

[identifier] Identifiers of modules, variables, methods, attributes and
labels must begin with a lowercase letter and can be followed by
letters, digits, or underscores. However, the usage of uppercase letters
(and camelcase) is discouraged and the usage of underscore to separate
words in identifiers is preferred: `some_identifier`.

Identifiers of classes and types must begin with a uppercase letter and
can be followed by letters, digits, or underscores. However, in classes,
the usage of camelcase is preferred while formal types should be written
all in uppercases: `SomeClass` and `SOME_VIRTUAL_TYPE`.

## Style

While Nit does not enforce any kind of source code formatting, the
following is encouraged:

-   indentation is done with the tabulation character and is displayed
    as 8 spaces;

-   lines are less than 80 characters long;

-   binary operators have spaces around them: `4 + 5`, `x = 5`;

-   columns (`:`) and commas (`,`) have a space after them but not
    before: `var x: X`, `[1, 2, 3]`;

-   parenthesis and brackets do not need spaces around them;

-   superfluous parenthesis should be avoided;

-   the `do` of methods and the single `do` is on its own line and not
    indented;

-   the other `do` are not on a newline.

## Comments and Documentation

[comment] As in many script languages, comments begin with a sharp (`#`)
and run up to the end of the line. Currently, there is no
multiline-comments.

A block of comments that precede any definition of module, class, or
property, is considered as its documentation and will be displayed as
such by the autodoc. At this point, documentation is displayed verbatim
(no special formatting or meta-information).

    # doc. of foo
    module foo

    # doc. of Bar
    class Bar
        # doc. of baz
        fun baz ...
    end

# Types, Literals and Operations

## Object

[Object] Nit is a full object language. Each value is the instance of a
class. Even the basic types described in this section.

`Object` is the root of the class hierarchy. All other classes,
including the basic ones, are a specialization of `Object`.

Classes, methods and operators presented in this section are defined in
the standard Nit library that is implicitly imported in every module.
Many other classes and methods are also defined in the standard library.
Please look at the specific standard library documentation for all
details.

## Int and Float

[Int][Float] `1`, `-1` are `Int` literals, and `1.0`, `-0.1` are `Float`
literals. Standard arithmetic operators are available with a common
precedence rules: `*`, `/`, and `%` (modulo) ; then `+` and `-`. Some
operators can be composed with the assignment (`=`).

    var i = 5
    i += 2
    print i # outputs 7

Conversion from `Int` to `Float` and `Float` to `Int` must be done with
the `to_f` and `to_i` methods.

## String

[String] Literal strings are enclosed within quotes (`"`). Common
escaping sequences are available (`\n`, `\t`, etc.) To insert a value
inside a literal string, include the values inside brackets (`{}`). `+`
is the concatenation operator but is less efficient than the bracket
form.

    var i = 5
    print "i={i}; i+1={i+1}" # outputs "i=5; i+1=6"

All objects have a `to_s` method that converts the object to a String.
`print` is a top-level method that takes any number of arguments and
prints to the standard output. `print` always add a newline, another
top-level method, `printn`, does not add the newline.

    var x: String
    x = 5.to_s # -> the String "5"
    print x, 6 # outputs "56"

## Bool

[Bool][is] `true` and `false` are the only two `Bool` values. Standard
Boolean operators are available with the standard precedence rule:
`not`; then `and`; then `or`.

Common comparison operators are available: `==` and `!=` on all objects;
`<`, `>`, `<=`, `>=` and `<=>` on `Comparable` objects (which include
`Int`, `String` and others).

-   `==`, `<`, `>`, `<=`, `>=` and `<=>` are standard Nit operators (it
    means they are redefinable).

-   `and`, `or` and `not` are not standard Nit operators: they are not
    redefinable, also they are lazy and have adaptive typing flow
    effects.

-   `==` is not for reference equality but for value equality (like
    `equals` in Java). There is a special reference equality operator,
    `is`, but it cannot be redefined and its usage is not recommended.
    Note also that while `==` is redefinable, it has a special adaptive
    typing flow effect when used with `null`.

-   `!=` is not a standard Nit operator. In fact `x != y` is
    syntactically equivalent to `not x == y`.

## Array

[Array] `Array` is a generic class, thus `Array[Int]` denotes an array
of integers and `Array[Array[Bool]]` denotes an array of array of
Booleans. Literal arrays can be declared with the bracket notation
(`[]`). Empty arrays can also be instantiated with the `new` keyword and
elements added with the `add` method. Elements can be retrieved or
stored with the bracket operator.

    var a = [1, 2, 3, 4] # A literal array of integers
    print a.join(":") # outputs "1:2:3:4"
    var b = new Array[Int] # A new empty array of integers
    b.add(10)
    b.add_all(a)
    b.add(20)
    print b[0] # outputs "10"
    print b.length # outputs "6"
    b[1] = 30
    print b.join(", ") # outputs "10, 30, 2, 3, 4, 20"

Note that the type of literal arrays is deduced using the static type
combination rule.

## Range

[Range] `Range` is also a generic class but accepts only `Discrete`
types (`Int` is discrete). There are two kinds of literal ranges, the
open one `[1..5[` that excludes the last element, and the closed one
`[1..5]` that includes it.

    print([1..5[.join(":")) # outputs "1:2:3:4"
    print([1..5].join(":")) # outputs "1:2:3:4:5"

Ranges are mainly used in `for` loops.

## HashMap

[HashMap] `HashMap` is a generic class that associates keys with values.
There is no literal hashmap, therefore the `new` keyword is used to
create an empty `HashMap` and the bracket operators are used to store
and retrieve values.

    var h = new HashMap[String, Int] 
    # h associates strings to integers
    h["six"] = 6
    print h["six"] + 1 # outputs "7"


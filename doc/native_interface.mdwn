# Native Interface

The Nit native interface allows the creation of modules partially written in Nit and C. In such a module, the Nit code defines or redefines classes (normally) and methods (normal Nit methods or extern methods). The C code can implement an extern method, link to an existing C library, callback to the Nit code. The module is represented by three files on disk (.nit, .nit.h and .nit.c).

## Extern methods

An extern method in a Nit method implemented in C code. Except for its implementation, it behaves like any other Nit method. It is a method with a receiver that can redefine or specialize an existing property, be redefined itself and even have virtual types in its signature.

Extern methods are declared like so in the Nit code:

    class A
        fun foo is extern
        fun bar( n : Char ) : Bool is extern
    end

The same methods are implemented in the C code under a similar signature:

    void A_foo___impl( A recv, void ) {
        printf( "in method A::foo, from C\n" );
    }
    int A_bar___impl( A recv, n : char ) {
        printf( "in method A::bar( %d ), from C\n", n );
        return 1;
    }

The name of the C implementation functions is composed of the class name and method name followed by "___impl". The Nit types primitives to C are converted in the C signature (as for Char and Bool) whereas Nit types unknown to C are kept opaque (as for the receiver of type A).

## Primitives types for C

## Callbacks

## Extern classes

## Compiling and linking

## Example
The example extern_methods.nit illustrate the native interface mechanism of Nit

* [[examples/extern_methods.nit|http://nitlanguage.org/nit.git/blob/HEAD:/examples/extern_methods.nit]]
* [[examples/extern_methods.nit.c|http://nitlanguage.org/nit.git/blob/HEAD:/examples/extern_methods.nit.c]]
* [[examples/extern_methods.nit.h|http://nitlanguage.org/nit.git/blob/HEAD:/examples/extern_methods.nit.h]]

You may notice that the FFI with Java is very similar to the [[FFI with C]]. This page highlights the difference and avoids repeating the information present in the documentation of the [[FFI with C]]. For this reason, it is strongly recommanded that you read [[FFI with C]] before this page.

# Extern methods implemented in Java

TODO

# Extern classes in Java

Nit extern classes wraps extern types to be used in Nit code. Thay allow pass data in and out of extern methods with ease. The single value of an instance of an extern class is the extern instance that it warps.

When the extern type of an extern class is in Java you get what we call a extern Java class. It is a Nit class wrapping a Java type. In Nit you can manipulate its instances pretty much like any other instances and in Java you will get a Java object.

## Declaration

An extern Java class is declared like any other extern class, however the extern type declarations must be preceded by `in "Java"`. It will thus look like this:

~~~~
extern class AndroidBundle in "Java" `{ android.os.Bundle `}
...
~~~~

To maintain the API coherence, the introduction of an extern Java class should declare two things:

* That it is subclass to JavaObject if it is not already through other super classes. 
* it should redefine the virtual type SELF with itself. This type is used by some methods of JavaObject such as...

A simple but complete extern Java class should look like this:

~~~~
extern class AndroidBundle in "Java" `{ android.os.Bundle `}
	super JavaObject
	redef type SELF: AndroidBundle

	# ...
end
~~~~

## Equivalent Java type

The equivalent Java type must respect the following conditions:

* It must be described by its full namespace (ex: `java.io.File`)
* It can use the Java format or the internat format (using respectively `.` or `/` between namespaces and class names)
* Inner classes must be specified using the `$` symbol between the names of the parent class and the inner class (ex: `android.content.SharedPreferences$Editor`)

Limitations:

* Java primitive types (including the array) cannot be used as the equivalent type. You should instead use existing classes in the Java module. 
* As of now, Java generic types also cannot be used as an extern type. However, this is a planned feature.

Additional notes about the equivalent Java type:

* It can be an interface, and have methods in Nit.
* It can specialize other extern classes and Nit interfaces.

# Nit objects in Java

TODO

# Java objects in Nit

TODO

# Common use cases

## Sub-class a Java class

TODO

## Java threads

TODO

# jwrapper

Having read the beginning of this page you know how to wrap Java services in Nit. You may have notice that some of the work is repetitive and that it requires a lot a boilerplate code. With this in mind, Frederic Vachon created the _jwrapper_ tool, a generator of Nit wrappers around Java classes.

## Installation and setup

1. Clone the Nit repository of Nit, install the needed dependencies and run `make` at the root.
2. Then, go to the folder at `contrib/jwrapper` and run `make`. This will create the executable, within the Nit repository, at `contrib/jsrapper/bin/jwrapper`.
3. Set the environment variable `NIT_DIR` to the path of your Nit repository. _jwrapper_ will use this variable to find existing wrappers of Java classes and automatically use them when necessary.

## Basic usage

1. Find the compile Java class to wrap, or compile it from source using `javac`. Some classes may need to be extracted from _jar_ archives. For example, classes for the Android library can be found in `platforms/android-*/android.jar` from the SDK.

2. Generate the wrapping code for the class `android.os.Bundle` with a call to:

    `jwrapper Bundle.class android_os_bundle.nit`

    This will create the file `android_os_bundle.nit` with the wrapper around the `Bundle` class. It will also define minimal wrappers around any other Java classes referenced but not already wrapped by the Nit library.

    Alternatively, you can use the `-c` option to _not_ generate those additional minimal wrappers. _jwrapper_ will instead comment the lines of code that are invalid without the referenced classes. They can be activated once the required class has also been wrapped.

3. Review the generated code and adapt it to you needs.

4. Use and import the generated module as you would with any other Nit modules. 

For more information, see _jwrapper_'s README file in your repository and [[available online|https://github.com/privat/nit/blob/master/contrib/jwrapper/README.md]]. 

# Limitations of the FFI with Java

The Java FFI has been designed with Android in mind and more specifically to be compiled against Android NDK's `jni.h`. For this reason, there is currently some limitations when targetting a desktop environment:

* The inner Java code block does not support adding inner classes.  This is a known missing feature, it can be fixed if there is a need for it. It does work when the target platform is Android. See the issue [[#769|https://github.com/privat/nit/issues/769]].

* There are some gcc warnings to be expected at compilation due to an incompatibility between the `jni.h` of the Android NDK and its desktop counterparts. See the issue [[#770|https://github.com/privat/nit/issues/770]].

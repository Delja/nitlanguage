# Native Interface

''Warning: the native interface is disabled in the current master branch. use the branch `oldnitc` if you need it.''

The Nit native interface allows the creation of modules partially written in Nit and C. In such a module, the Nit code defines or redefines classes (normally) and methods (normal Nit methods or extern methods). The C code can implement an extern method, link to an existing C library, callback to the Nit code. The module is represented by three files on disk (.nit, .nit.h and .nit.c).

To use all the features of the native interface, the C code must import a file generated specifically for the module. This file, _<my\_module.\_nitni.h>_, is usually included in the _.nit.h_ file.

On this page, we present the different aspects of the Nit native interface. We do not present all the details of the C code, but it follows a standard structure and syntax and can be understood by taking a look at the example or by using the _nits_ tool. 

## Extern methods

An extern method in a Nit method implemented in C code. Except for its implementation, it behaves like any other Nit method. It is a method with a receiver that can redefine or specialize an existing property, be redefined itself and even have virtual types in its signature.

Extern methods are declared like so in the Nit code:

    class A
        fun foo is extern
        fun bar( n : Char ) : Bool is extern
    end

The same methods are implemented as C functions code under a similar signature:

    void A_foo___impl( A recv ) {
        printf( "in method A::foo, from C\n" );
    }
    int A_bar___impl( A recv, char n ) {
        printf( "in method A::bar( %d ), from C\n", n );
        return 1;
    }

The name of the C implementation functions is composed of the class name and method name followed by "___impl". The Nit types primitives to C are converted in the C signature (as for Char and Bool) whereas Nit types unknown to C are kept opaque (as for the receiver of type A).

## Primitive Nit types in C

For easier exchanges between Nit and C, Nit types that are primitive to C are converted automatically between languages. This conversion works both ways.

* A Nit __Char__ is converted to the C __char__.
* A Nit __Bool__ is converted to the C __int__ where 0 is true and everything else is false.
* A Nit __Int__ is converted to the C __bigint__, _bigint_ is usually the size of _long long - 1 bit_.
* A Nit __NativeString__ is converted to the C __char*__. Instances of _String_ must be converted to a _NativeString_ using the _String::to_cstring_ function.

## Nit types and callbacks

All Nit types that are not primitive to C are represented by an opaque C type. This C type is generated for each module with a name specific to the represented Nit type. Usually the C type will have the same name as its Nit equivalent, with the exception of nullable types (in which the type name is prefixed with _nullable\__) and generic types (not yet fully implemented). C structures of this type can be used to call Nit methods from C code.

First of all, callbacks from the C code must be declared in the Nit code. This allows the compiler to further optimize your program and statically check for errors in your C code. Using a similar example as before:

    class A
        fun baz( msg : String ) is extern import String::length, String::to_cstring
    end

In the C implementation, these methods can be called using the class name and method name seperated by an underscore:

    void A_baz___impl( A recv, String msg ) {
        char *c_msg;
        int msg_len;

        c_msg = String_to_cstring( msg ); /* msg.to_cstring */ 
        msg_len = String_length( msg ); /* msg.length */
        
        printf( "received msg: %s, of length = %d\n", c_msg, msg_len );
    }

As you may have noticed, the callback functions in C use a similar name to the equivalent Nit method and the implementation functions. This pattern can be used to predict the name of the C function to called a given Nit method.

It is also possible to callback the Nit language for more than methods:

* Declaring an import of __super__ in Nit will allow to call super from C using a function similar to _A_baz___super( recv )_.
* Declaring an import a constructor will allow it to be called from C as _A new_A()_ for the anonymous constructor of the class A or _A new\_A\_name()_ for a named constructor.
* Casts can de declared as an import in Nit with three forms; __A as(B)__, __String as nullable__, __String as not nullable__. The first form is used to cast from any to any type. The second and third forms are used to cast between nullables and non-nullables. In the C code, those imports allows to use two set of funtions, one for the type check and one for the cast itself. With these examples we would get _int A\_is\_a\_B( A )_ and _B A\_as\_B( A )_ for the first form; _nullable\_String String\_as\_nullable( String )_ for the second form (no check is necessary) as well as _int String\_is\_null( nullable\_String )_ and _String String\_as\_not\_null_ for the third form.

## Extern classes

An extern Nit class associates directly a C type to a Nit class. An instance of this class can then be used like other primitives types to C and will have and equivalent representation in both languages.

An extern class is declared in Nit by replacing the _class_ keyword with _extern_:

    extern A
    end

Its C type equivalent is defined in the C code, usually in the header .nit.h before including the generated file (_._nitni.h_), like so:

    #define A my_struct*

The equivalent C type _must_ be a pointer and the Nit class can only be sublass to other extern classes or interfaces.

The single value of an instance of an extern class is its value in C, because of that it cannot have any attributes. An extern Nit classes still can have methods (normal and extern) but only extern constructors.

Extern constructors are declared similarly to extern methods, for example:

    extern A
        new is extern
        new named is extern
    end

These constructors are implemented like an extern method but with a different signature:

    A new_A___impl() {
        return malloc( sizeof( my_struct) );
    }
    A new_A_named___impl() {
        A a = malloc( sizeof( my_struct) );
        a->naming = 1;
        return a;
    }

You _must_ free any resources you allocated in C code, the Nit system do not manage these.

## Global C references

Nit objects passed as argument to a C implementation function are guaranteed to be valid until the function return. So it is for Nit objects returned from callbacks to Nit code. However, if you need to keep a Nit object between functions, in a global C variable, you have to notify the native interface for it to stay valid.

For example, before saving an instance of the class A in a global variable, you must call _A\_incr\_ref( A )_ on the instance. From then on, the Nit system will update this reference at each garbage collection so it stays valid, even after the current extern method returns. To free such a reference, call _A\_derc\_ref( A )_.

## A tool!

The tool _nits_ is available with the current Nit distribution to simplify writing modules using the native interface. It does four things:

* It generates stub files for a module with the basic C file structure and C imports
* It generates the C implementation functions signature for extern Nit methods
* It generates helper documentation for each extern methods with the signatures of declared callbacks to Nit
* It generates the basic C equivalent for extern classes

To use _nits_, follow these steps:

* Write the Nit part of your module (including extern methods declaration and extern classes)
* Call _nits_ with _nits -i my\_module.nit_ to generate the _my\_module.nit.c_ and _my\_module.nit.h_ files. Be careful, the _-i_ option overwrites your custom C code in those files.
* Customize the generated C files.
* If necessary, modify the Nit file and rerun _nits my\_module.nit_ (without _-i_!) to generate stub files (_my\_module.sub.nit.c_, etc) with all of the C code for the latest version of the Nit code.

## Compiling and linking

Compiling a Nit program using the most basic functionality is simple:

    nitc my_module.nit

However, to link with an external library you can use more options. Let's say the C code of your module uses the SDL graphic library, you must specify the library name for linking and you can specify where to fing the header files:

    nitc my_module.nit --cc-lib-name SDL --cc-header-path /usr/include/SDL

## .nit.args files

The compilation options passed to nitc can be directly associatied with the module with .nit.args files. 

To continue with the previous example, the module my\_module needs to be linked with the SDL library. The needed compilation options can be declared in the my\_module.nit.args file as so:

    --cc-lib-name SDL --cc-header-path /usr/include/SDL

The options specified in this file will be used to compile all Nit program importing the module my\_module. Only options related to C compilation are supported by .nit.args files as of now.

## Example
The example extern_methods.nit illustrates a normal use of the Nit native interface.

* [[examples/extern_methods.nit|http://nitlanguage.org/nit.git/blob/HEAD:/examples/extern_methods.nit]]
* [[examples/extern_methods.nit.c|http://nitlanguage.org/nit.git/blob/HEAD:/examples/extern_methods.nit.c]]
* [[examples/extern_methods.nit.h|http://nitlanguage.org/nit.git/blob/HEAD:/examples/extern_methods.nit.h]]

## References
* [[L'interface native de Nit, un langage de programmation à objets; Alexis Laferrière; Mémoire; UQAM |http://xymus.net/alaferriere-memoire.pdf]]

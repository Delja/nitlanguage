# FFI with C

The Nit Foreign Function Interface (FFI) allows to nest C code within a Nit file. Doing so, you can implement Nit methods in C, declare the C type equivalent to a Nit class, and write supporting C code (such as imports). This page is an introduction to different aspects of the Nit FFI.

Common use cases of the FFI is to optimize a method or wrap existing C libraries. In case of a wrapper, the C code manages calls to the C library functions and callbacks to Nit. To know more about wrappers using the FFI, see the page [[wrapping C libraries]].

# Extern methods

An extern method is a Nit method implemented with C code. Except for its implementation, it behaves like any other Nit method. It has a receiver, can refine or specialize an existing property, be refined itself and even have virtual types in its signature. 

Extern methods are declared and implemented like so in the Nit code:

    class A
        fun foo `{
            printf( "in method A::foo, from C\n" );
        `}
        fun bar( n : Char ) : Bool `{
            printf( "in method A::bar( %d ), from C\n", n );
            return 1;
        `}
    end

Notice that the body of the previous methods are implemented in C. This code behaves as a C function with a hidden signature. For the previous methods, the hidden signatures are:

    void A_foo___impl( A recv ) 
    int A_bar___impl( A recv, char n )

The Nit types considered as primitive to C are converted in the C signature (as for Char and Bool) whereas Nit types unknown to C are kept opaque (as for the receiver of type A).

# Primitive Nit types in C

For easier passage between Nit and C, Nit types that are primitive to C are converted automatically. This conversion works both ways.

## Primitive types between Nit and C

| Nit type    | C type | Notes |
|:------------|:-------|:------------|
| `Int`       | `long`   | The normal primitive type in C |
| `Bool`      | `int`    | Where 0 is false and everything else true |
| `Float`     | `double` |  |
| `Char`      | `char`   |  |
| `NativeString` | `char *` | The standard C string |
| `Pointer`   | `void *`    | A general pointer |

# Nit types in C

All Nit types that are not primitive to C are represented by an opaque C type. _The opaque C type is generated when needed with a name corresponding to the Nit type_. Usually the C type will have the same name as its Nit equivalent, with the exception of nullable types (in which the type name is prefixed with _nullable\__) and generic types (see examples below).

     
## Some equivalent types between Nit and C

| Nit type    | C type | Note |
|:------------|:-------|:------------|
| ... | ... | ... |
| `Object`    | `Object` | A generated opaque type |
| `String`    | `String` | A generated opaque type (`NativeString` is more practical in C) |
| `nullable Object` | `nullable_Object` | Using casts (discussed later on this page) it can be cast to `Object` |
| `Array[String]` | `Array_of_String` | There is a `_of_` between the class name and it's parameter. |
| `Map[Int, String]` | `Map_of_Int_String` | The parameters are separated only with a `_` |
| `nullable Array[String]` | `nullable_Array_of_String` | These can get quite long, but they are precise! |

# Callbacks to Nit from C

First of all, callbacks from the C code must be declared after the signature of the Nit method. This allows the compiler to further optimize your program and statically check for errors in your C code. In the C implementation, these methods can be called using the class name and method name seperated by an underscore:

    class A
        var attr = 1234
        fun baz( msg : String ) import String::length, String::to_cstring `{
            char *c_msg;
            int msg_len;

            c_msg = String_to_cstring( msg ); /* msg::to_cstring */ 
            msg_len = String_length( msg ); /* msg::length */
        
            printf( "received msg: %s, of length = %d\n", c_msg, msg_len );

            printf( "old attr %d\n", A_attr(recv) ); /* get A::attr */
            A_attr__assign( recv, msg_len ); /* set A::attr */
        `}
    end

As you may have noticed, the callback functions in C use a similar name to the equivalent Nit method and the implementation functions. This pattern can be used to predict the name of the C function to called a given Nit method.

It is also possible to callback the Nit language for more than methods:

* Declaring an import of `super` in Nit will allow to call super from C using a function similar to `A_baz___super( recv )`.
* Declaring an import a constructor will allow it to be called from C as `A new_A()` for the anonymous constructor of the class A or `A new_A_name()` for a named constructor.
* Casts can de declared as an import in Nit with three forms; `A as(B)`, `String as nullable`, `String as not nullable`. The first form is used to cast from any to any type. The second and third forms are used to cast between nullables and non-nullables. In the C code, those imports allows to use two set of funtions, one for the type check and one for the cast itself. With these examples we would get `int A_is_a_B( A )` and `B A_as_B( A )` for the first form; `nullable_String String_as_nullable( String )` for the second form (no check is necessary) as well as `int String_is_null( nullable_String )` and `String String_as_not_null` for the third form.

# Extern classes

An extern Nit class is associated ta an equivalent C type. An instance of this class can then be used like other primitives types to C and will have an equivalent representation in both languages.

An extern class is declared in Nit by replacing the _class_ keyword with _extern_. The C type equivalent is defined in C rigth after the class name.

    extern A `{ my_struct* `}
    end

The equivalent C type _must_ be a pointer and the Nit class can only be sublass to other extern classes or interfaces.

The single value of an instance of an extern class is its value in C, because of that it cannot have any attributes. An extern Nit classes still can have methods (normal and extern) but only extern constructors.

Extern constructors are declared similarly to extern methods, for example:

    extern A `{ my_struct* `}
        new `{
            return malloc( sizeof( my_struct) );
        `}
        new named `{
            A a = malloc( sizeof( my_struct) );
            a->naming = 1;
            return a;
        `}
    end

You _must_ free any resources you allocated in C code, the Nit system do not manage these.

# Global C references

Nit objects passed as argument to a C implementation function are guaranteed to be valid until the function return. So it is for Nit objects returned from callbacks to Nit code. However, if you need to keep a Nit object between functions, in a global C variable, you have to notify the native interface for it to stay valid.

For example, before saving an instance of the class A in a global variable, you must call `A_incr_ref( A )` on the instance. From then on, the Nit system will update this reference at each garbage collection so it stays valid, even after the current extern method returns. To free such a reference, call `A_derc_ref( A )`.

# Compiling and linking

Compiling a Nit program using the basic FFI is straight forward:

    nitc my_module.nit

When using a shared C library you will have to specify more options for the compiler. 

## Passing options to the C compiler

For advanced use of the FFI, you'll often need to pass custom options to the C compiler. The most common are probably: `-l` to link with a shared library and `-I` to specify where to find C header files. 

The Nit FFI offers 3 annotations to use on the modules nesting C code: `c_compiler_options`, `c_linker_options` and `pkgconfig`.

### pkgconfig

The program `pkg-config` knows what options are needed to compile a specific with popular C libraries. The annotation `pkgconfig` call the program in the background to get the options.

Usage examples:

    module glesv2 is pkgconfig # Will use the options for the name module `pkg-config glesv2`

    module gtk3_4 pkgconfig("gtk+-3.0")

### c_compiler_options and c_linker_options

When you need specialized options or a library unsupported by pkg-config, you can use the annotations `c_compiler_options` and `c_linker_options`. They pass options directly the compiler and linker.

They can be used with a special function call to `exec` which will use the result of a local program instead of a string.

Basic usage example:

    module sdl is
        c_compiler_options("-I", "/usr/include/SDL")
        c_linker_options("-l", "SDL")
    end

Same example with calls to `exec`, where we use the external program `sdl-config`:

    module sdl is
        c_compiler_option(exec("sdl-config", "--cflags"))
        c_linker_option(exec("sdl-config", "--libs"), "-lSDL_image -lSDL_ttf")
    end

# Example using the FFI

The example extern_methods.nit illustrates a normal use of the Nit FFI.

* [[examples/extern_methods.nit|http://nitlanguage.org/nit.git/blob/HEAD:/examples/extern_methods.nit]] (not yet updated)

# References
* [[L'interface native de Nit, un langage de programmation à objets; Alexis Laferrière; Mémoire; UQAM |http://xymus.net/alaferriere-memoire.pdf]]

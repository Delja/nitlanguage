# Constructors and Instantiation

[init] `init` declares constructors in concrete and in abstract classes.
The role of constructors is basically to initialize the attributes of
the class. Constructors can have: a visibility (by default it is
public), a name (by default, constructors are anonymous) and parameters.
They cannot have a return value.

    class Foo
        init(i:Int) do ...
        init herp do ...
        init derp(i, j: Int) do ...
    end

## Class Instantiation

[new] `new` instantiates a concrete class using a specific constructor.

    var x = new Foo(4) # invoke init
    var y = new Foo.herp # invoke herp
    var z = new Foo.derp(1, 2) # invoke derp

Note that syntactically, `new Bar` means “instantiate `Bar` with the
anonymous constructor”, and `new Bar.foo` means “instantiate `Bar` with
the constructor named `foo`”, but `(new Bar).foo` means “instantiate
`Bar` with the anonymous constructor then call the method `foo` on the
result”.

Constructors can also be called by other constructors in order to
factorize or delegate parts of the construction process. In other
constructors, `init` denotes the anonymous constructor.

    class Foo
        init(i: Int) do self.derp(i.to_s)
        init herp do self.init(5)
        init derp(s: String) do ...
    end

## Initialization of Attributes

[initialization][isset] The tricky part in constructors is the
initialization of attributes since they cannot be initialized in an
atomic way. The various steps apply in the following order:

-   Attributes typed by a nullable type are initialized with `null`;
    other attributes remain uninitialized.

-   Default values of all attributes (including inherited ones) are
    computed in the order of their definitions.

-   The constructor designated in the `new` is executed.

-   During the constructor execution (including any methods or other
    constructors called), accessing an uninitialized attribute aborts
    the program.

-   After the execution of the constructor designated in the `new`, if
    some attributes remain uninitialized, the program aborts.

`isset` can be used to avoid aborting during the construction. It checks
if an attribute is defined.

    class Foo
        var x: Int
        fun safe_x: nullable Int
        do
            if isset self.x then
                return self.x
            else
                return null
            end
        end
        init
        do
            print safe_x or else 0 # outputs 0
            # "print x" would have aborted the program
            self.x = 5
            print safe_x or else 0 # outputs "5"
            print x # outputs "5". It is safe.
        end
    end
    var f = new Foo

## Free and Inherited Constructors

[init inheritance] When there is no constructor defined in a concrete
class or in an abstract class that specializes only interfaces (`Object`
is always a superclass), a free anonymous constructor is implicitly
declared. This free constructor gathers all attributes without a initial
value and assign them in order. If all attributes have an initial value
(or if there is no attributes), the free constructor has no parameters.

    class Foo
        var x: Int
        var y: String
        var z: Int = 0
        # a free init(x: Int, y: String) is implicit
    end
    var f = new Foo(5, "five") # OK

When there is no constructors defined in a concrete class or in an
abstract class, and this class has only one direct superclass that is a
concrete class or an abstract class, and all attributes defined in this
class have an initial value, then all constructors of the superclass are
inherited.

    class Bar
        super Foo
        var t: String = "Hello"
        # init(Int, String) is inherited
    end

If none of these two cases apply, then there is a compilation error. The
programmer usually has to define its own constructors for the class.

    class Baz
        super Foo
        var u: Int
        # Compile error: a constructor must be defined
    end

